
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ASL FLIGHT SIMULATOR</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; user-select: none; }
        
        /* 仪表盘布局 */
        #hud-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; display: flex; flex-direction: column; justify-content: space-between;
            padding: 25px; box-sizing: border-box; z-index: 10;
        }

        .hud-top-left { display: flex; gap: 20px; }
        
        .instrument {
            background: rgba(10, 20, 30, 0.75); 
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-left: 4px solid #00aaff;
            backdrop-filter: blur(8px); 
            padding: 10px 18px; 
            color: #eee; 
            min-width: 100px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.5);
        }
        
        .label { font-size: 10px; color: #88ccff; font-weight: 600; letter-spacing: 1px; margin-bottom: 4px; display:block; text-transform: uppercase;}
        .value { font-size: 26px; font-weight: 700; font-family: 'Consolas', monospace; letter-spacing: -1px; }
        .unit { font-size: 12px; color: #888; margin-left: 4px; font-weight: 400;}

        /* 油门推杆 */
        #throttle-wrapper {
            position: absolute; left: 30px; bottom: 120px; width: 12px; height: 240px;
            background: rgba(0,0,0,0.6); border: 1px solid #555; border-radius: 8px;
            padding: 2px;
        }
        #throttle-fill {
            position: absolute; bottom: 2px; left: 2px; width: 12px; height: 0%;
            background: linear-gradient(to top, #4caf50, #ffeb3b, #ff5722);
            border-radius: 4px; transition: height 0.1s;
        }
        #throttle-label {
            position: absolute; left: 50px; bottom: 120px; color: #fff; font-size: 12px; font-weight: bold;
            transform: rotate(-90deg); transform-origin: left bottom; opacity: 0.7;
        }

        /* 警告信息 */
        #center-warning {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #ff3333; font-size: 24px; font-weight: bold; border: 2px solid #ff3333;
            padding: 10px 30px; background: rgba(0,0,0,0.7); display: none;
        }

        /* 启动画面 */
        #splash {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(to bottom, #1a2a3a, #000000);
            z-index: 999; display: flex; flex-direction: column; align-items: center; justify-content: center;
            color: white;
        }
        h1 { font-size: 64px; margin: 0; font-weight: 300; letter-spacing: 10px; text-transform: uppercase; }
        h1 b { font-weight: 900; color: #00aaff; }
        .controls-grid {
            display: grid; grid-template-columns: auto auto; gap: 15px 30px; margin-top: 40px;
            text-align: left; background: rgba(255,255,255,0.05); padding: 30px; border-radius: 4px;
            border: 1px solid rgba(255,255,255,0.1);
        }
        .key-box { font-family: monospace; color: #00aaff; font-weight: bold; margin-right: 10px;}
        button {
            margin-top: 50px; padding: 16px 60px; font-size: 18px; font-weight: 600; border: 1px solid #00aaff;
            background: rgba(0, 170, 255, 0.2); color: #fff; cursor: pointer; letter-spacing: 2px;
            transition: all 0.3s; text-transform: uppercase;
        }
        button:hover { background: #00aaff; color: #000; box-shadow: 0 0 30px #00aaff; }
        
        .loader { font-size: 12px; color: #666; margin-top: 20px; }
    </style>
</head>
<body>

    <div id="splash">
        <h1>ASL <b>FLIGHT SIMULATOR</b></h1>
        <p style="color:#8899aa; letter-spacing: 3px;"><b>BETA</b></p>
        
        <div class="controls-grid">
            <div><span class="key-box">SHIFT</span> Thrust Up</div>
            <div><span class="key-box">SPACE</span> Brake</div>
            <div><span class="key-box">W / S</span> Pitch</div>
            <div><span class="key-box">A / D</span> Roll</div>
            <div><span class="key-box">Q / E</span> Yaw</div>
            <div><span class="key-box">V</span> View</div>
        </div>

        <div style="margin-top:20px; color:#aa8800; font-size:13px;">
            ⚠ Made by Zhanyi Zhou
        </div>

        <button onclick="startGame()">LET'S GO!</button>
    </div>

    <div id="hud-layer">
        <div class="hud-top-left">
            <div class="instrument">
                <span class="label">Airspeed</span>
                <span class="value" id="hud-spd">0</span> <span class="unit">KTS</span>
            </div>
            <div class="instrument">
                <span class="label">Altitude</span>
                <span class="value" id="hud-alt">0</span> <span class="unit">FT</span>
            </div>
            <div class="instrument">
                <span class="label">Heading</span>
                <span class="value" id="hud-hdg">000</span> <span class="unit">DEG</span>
            </div>
            <div class="instrument" style="border-left-color: #ffcc00;">
                <span class="label" style="color:#ffcc00">Fuel Flow</span>
                <span class="value" id="hud-rpm">0</span> <span class="unit">%</span>
            </div>
        </div>

        <div id="throttle-wrapper">
            <div id="throttle-fill"></div>
        </div>
        <div id="throttle-label">THRUST</div>
        
        <div id="center-warning">STALL WARNING</div>
    </div>

    <div id="canvas-container"></div>

    <!-- LIBS -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/simplex-noise/2.4.0/simplex-noise.min.js"></script>

    <script>
        // --- 常量配置 (真实物理参数) ---
        const CONFIG = {
            runwayZ: 4000,       // 跑道起点Z坐标
            runwayX: -1500,      // 跑道中心X坐标
            
            // 物理参数 - 模拟一架重型喷气式战斗机或轻型商务机
            mass: 18000,         // 18吨 (真实重量感)
            maxThrust: 4200000,   // 420kN (强大的推力以匹配重量)
            dragCoeff: 0.035,    // 阻力系数
            liftCoeff: 0.004,    // 升力系数
            wingArea: 70,        // 机翼面积
            gravity: 9.81,       // 标准重力
            
            // 操控响应 (由于质量大，响应会变慢，模拟惯性)
            rotDamping: 2.5,     // 旋转阻尼
            pitchSpeed: 1.2,
            rollSpeed: 2.0,
            yawSpeed: 0.8
        };

        // --- 全局变量 ---
        let scene, camera, renderer, clock;
        let planeGroup, propL, propR, shadowPlane;
        let input = { w:0, s:0, a:0, d:0, q:0, e:0, shift:0, space:0 };
        let cameraMode = 0; // 0: Chase, 1: Cockpit, 2: Tower

        // 物理状态对象
        const physics = {
            pos: new THREE.Vector3(CONFIG.runwayX, 2.8, CONFIG.runwayZ), // 修正：高度2.8匹配轮子
            vel: new THREE.Vector3(0, 0, 0),
            acc: new THREE.Vector3(0, 0, 0),
            quat: new THREE.Quaternion(),
            rotVel: new THREE.Vector3(0, 0, 0), // 角速度
            throttle: 0,
            brake: false,
            grounded: true,
            crashed: false
        };

        function startGame() {
            document.getElementById('splash').style.display = 'none';
            init();
            animate();
        }

        function init() {
            clock = new THREE.Clock();

            // 渲染器设置 - 追求写实
            renderer = new THREE.WebGLRenderer({ antialias: true, logarithmicDepthBuffer: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.0;
            renderer.outputEncoding = THREE.sRGBEncoding;
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // 场景
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB); // 真实的天空蓝
            scene.fog = new THREE.Fog(0x87CEEB, 2000, 15000); // 大气透视

            // 相机
            camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.5, 100000);

            // 环境光 (冷色调阴影)
            const hemiLight = new THREE.HemisphereLight(0xffffff, 0x3b4c5a, 0.6); 
            scene.add(hemiLight);

            // 太阳光 (暖色调直射)
            const dirLight = new THREE.DirectionalLight(0xfff0dd, 1.4);
            dirLight.position.set(3000, 5000, 2000);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 4096; // 高清阴影
            dirLight.shadow.mapSize.height = 4096;
            const d = 5000;
            dirLight.shadow.camera.left = -d; dirLight.shadow.camera.right = d;
            dirLight.shadow.camera.top = d; dirLight.shadow.camera.bottom = -d;
            dirLight.shadow.camera.far = 15000;
            dirLight.shadow.bias = -0.0001;
            scene.add(dirLight);

            // 构建世界
            createRealisticWorld();
            createDetailedPlane();

            // 监听
            window.addEventListener('resize', onResize);
            document.addEventListener('keydown', (e) => handleKey(e, 1));
            document.addEventListener('keyup', (e) => handleKey(e, 0));
        }

        // --- 物理引擎核心 (Newtonian Physics) ---
        // --- 物理引擎核心 (Newtonian Physics) ---
const UP = new THREE.Vector3(0, 1, 0);
const FORWARD = new THREE.Vector3(0, 0, -1);
const GRAVITY_VECTOR = new THREE.Vector3(0, -CONFIG.gravity * CONFIG.mass, 0);
const tempVec3 = new THREE.Vector3();
const localForces = new THREE.Vector3();

// 将 THREE.js 的速度（单位: meter/s）转换为 KTS
function speedToKnots(speed) {
    return speed * 1.94384;
}

function updatePhysics(dt) {
    if (physics.crashed) return;

    // 1. **更新推力 (Throttle)**
    const thrustStep = 0.5 * dt; // 油门响应速度
    if (input.shift) {
        physics.throttle = Math.min(1.0, physics.throttle + thrustStep);
    } else {
        // 自动怠速/缓慢减速
        physics.throttle = Math.max(0.0, physics.throttle - thrustStep * 0.2);
    }

    // 2. **姿态控制力矩 (Rotation - Pitch, Roll, Yaw)**
    
    // a. 获取用户输入
    const pitchInput = input.s - input.w; // S: 抬头 (Pitch Up, 绕X轴负), W: 低头 (Pitch Down, 绕X轴正)
    const rollInput = input.d - input.a;   // D: 右滚 (Roll Right, 绕Z轴负), A: 左滚 (Roll Left, 绕Z轴正)
    const yawInput = input.e - input.q;    // E: 右偏 (Yaw Right, 绕Y轴负), Q: 左偏 (Yaw Left, 绕Y轴正)
    
    // b. 计算角加速度 / 施加力矩
    // 使用简单的角加速度模型，忽略惯性张量简化
    const torque = new THREE.Vector3(
        pitchInput * CONFIG.pitchSpeed, // X轴力矩 (俯仰)
        yawInput * CONFIG.yawSpeed,     // Y轴力矩 (偏航)
        rollInput * CONFIG.rollSpeed    // Z轴力矩 (滚转)
    ).multiplyScalar(dt);

    // c. 阻尼 (模拟空气阻力，防止永不停止的旋转)
    // 角度速度阻尼: 抵抗当前的角速度
    physics.rotVel.multiplyScalar(1.0 - CONFIG.rotDamping * dt);

    // d. 更新角速度 (加速度 -> 速度)
    physics.rotVel.add(torque);

    // e. 更新姿态 (角速度 -> 四元数)
    // 根据角速度计算一个旋转增量四元数
    const deltaRotation = new THREE.Quaternion();
    const rotAxis = physics.rotVel.clone().normalize();
    const rotAngle = physics.rotVel.length() * dt;
    deltaRotation.setFromAxisAngle(rotAxis, rotAngle);
    
    // 应用到当前姿态: q_new = q_current * q_delta
    physics.quat.multiply(deltaRotation).normalize();
    
    // 简化: 强制地面时的姿态（防止在跑道上倾斜）
    if (physics.grounded) {
        // 仅在地面上时，限制滚转和俯仰
        const euler = new THREE.Euler().setFromQuaternion(physics.quat, 'YXZ');
        euler.x = 0; // 俯仰归零
        euler.z = 0; // 滚转归零
        physics.quat.setFromEuler(euler);
    }


    // 3. **线位移力 (Forces)**
    
    // 重置力
    localForces.set(0, 0, 0);

    // a. 推力 (Thrust)
    // 推力方向沿着飞机的本地 Z 轴负方向（飞机前进方向）
    const thrustMag = CONFIG.maxThrust * physics.throttle;
    const thrustVector = FORWARD.clone().multiplyScalar(thrustMag); // 在本地坐标系中

    // b. 气动力 (Aerodynamics: Lift & Drag)
    // V² * 密度 * 系数
    const speed = physics.vel.length();
    const airDensity = 1.225; // 假设海平面标准大气密度
    const V_sq = speed * speed;
    const dynamicPressure = 0.5 * airDensity * V_sq;

    // * 升力 (Lift)
    // 升力垂直于飞机的速度向量，但简化为垂直于机翼（本地Y轴）
    const angleOfAttack = 0.05; // 简化为常数 AOA，或可基于俯仰角和速度向量计算
    const liftMagnitude = dynamicPressure * CONFIG.liftCoeff * CONFIG.wingArea * (speedToKnots(speed) > 50 ? 1 : 0); // 速度过低无升力
    
    // 升力在本地坐标系中沿着 Y 轴正方向
    const liftVector = UP.clone().multiplyScalar(liftMagnitude); // 在本地坐标系中
    
    // * 阻力 (Drag)
    // 阻力与速度方向相反
    const dragMagnitude = dynamicPressure * CONFIG.dragCoeff * CONFIG.wingArea;
    
    // 阻力在本地坐标系中沿着 Z 轴正方向（与前进方向相反）
    const dragVector = FORWARD.clone().negate().multiplyScalar(dragMagnitude); // 在本地坐标系中
    
    // c. 刹车/地面摩擦力 (Brake / Ground Friction)
    physics.brake = input.space > 0;
    let groundFriction = 0;
    if (physics.grounded) {
        if (physics.brake) {
            groundFriction = speed * CONFIG.mass * 3.5; // 刹车阻力
        } else {
            groundFriction = speed * CONFIG.mass * 0.1; // 滚动阻力
        }
    }
    const frictionVector = FORWARD.clone().negate().multiplyScalar(groundFriction); // 在本地坐标系中

    // d. 集中所有本地力: 推力 + 升力 + 阻力 + 摩擦力
    localForces.add(thrustVector).add(liftVector).add(dragVector).add(frictionVector);


    // 4. **转换力到世界坐标系并应用牛顿第二定律**
    
    // 将本地力向量转换为世界坐标系
    const worldForce = localForces.clone().applyQuaternion(physics.quat);

    // 施加世界力: 重力 + 转换后的本地力
    worldForce.add(GRAVITY_VECTOR);
    
    // F = ma -> a = F/m
    physics.acc.copy(worldForce).divideScalar(CONFIG.mass);
    
    // 5. **更新速度和位置 (Integration)**
    
    // v_new = v_current + a * dt
    physics.vel.add(physics.acc.clone().multiplyScalar(dt));

    // *地面限制检查 (Ground Constraint)*
    physics.grounded = physics.pos.y <= 0.2; // 简化: 假设地面在Y=0
    
    if (physics.grounded) {
        // 如果接地，速度的Y分量强制为零，并模拟非完全弹性碰撞损失
        physics.vel.y = 0; 
        physics.vel.x *= 0.99; 
        physics.vel.z *= 0.99; 
        physics.pos.y = 0.2; // 强制停留在地面高度
        
        // 速度过低时停下
        if (physics.vel.length() < 0.1) {
            physics.vel.set(0, 0, 0);
        }
    } else {
        // 在空中时，侧向速度会衰减
        physics.vel.x *= 1.0 - dt * 0.01;
        physics.vel.z *= 1.0 - dt * 0.01;
    }

    // p_new = p_current + v * dt
    physics.pos.add(physics.vel.clone().multiplyScalar(dt));

    // 6. **失速警告 (Stall Warning)**
    const stallSpeed = speedToKnots(15); // 15 m/s 约 30 KTS
    if (!physics.grounded && speedToKnots(speed) < stallSpeed) {
        document.getElementById('center-warning').style.display = 'block';
    } else {
        document.getElementById('center-warning').style.display = 'none';
    }
}
        // --- 视觉构建：写实风格 ---
        function createRealisticWorld() {
            // 1. 地形 (Terrain)
            // 使用中心平坦，边缘起伏的逻辑
            const simplex = new SimplexNoise();
            const size = 60000;
            const segs = 256;
            const geo = new THREE.PlaneGeometry(size, size, segs, segs);
            const pos = geo.attributes.position;
            const colors = [];

            // 写实调色板
            const cConcrete = new THREE.Color(0x606060); // 机场地面灰
            const cGrass = new THREE.Color(0x3a5f0b);    // 深沉的植被绿
            const cDirt = new THREE.Color(0x5a4d3b);     // 泥土色
            const cSand = new THREE.Color(0x8a7f65);     // 岸边沙色
            
            // 定义平原区域半径
            const flatRadius = 5000;

            for(let i=0; i<pos.count; i++){
                let x = pos.getX(i);
                let y = pos.getY(i); // PlaneGeometry Z is Y here
                
                let h = 0;
                let col = cGrass; // 默认草地

                const dist = Math.sqrt(x*x + y*y);

                // 机场区域 (人工平整) - 位于左侧
                // 精确匹配 CONFIG.runwayX
                const inAirport = (Math.abs(x - CONFIG.runwayX) < 1000 && Math.abs(y) < 4500);
                
                if (inAirport) {
                    h = 0;
                    // 机场地面颜色稍微不同
                    col = new THREE.Color(0x4a6f1b); 
                } else if (dist < flatRadius) {
                    // 城市平原区
                    h = 0;
                    // 城市地面加一点噪点变化
                    if ((Math.sin(x*0.01) * Math.cos(y*0.01)) > 0) col = new THREE.Color(0x355515);
                } else {
                    // 远山
                    let n = simplex.noise2D(x*0.0001, y*0.0001);
                    h = Math.max(0, n * 2500);
                    // 缓坡过渡
                    if (dist < flatRadius + 2000) {
                        h *= (dist - flatRadius) / 2000;
                    }
                    
                    if (h > 500) col = cDirt;
                    else col = cGrass;
                }

                pos.setZ(i, h);
                colors.push(col.r, col.g, col.b);
            }
            geo.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            geo.computeVertexNormals();
            
            const terrain = new THREE.Mesh(geo, new THREE.MeshStandardMaterial({ 
                vertexColors: true, 
                roughness: 0.9, 
                metalness: 0.05 
            }));
            terrain.rotation.x = -Math.PI/2;
            terrain.receiveShadow = true;
            scene.add(terrain);

            // 2. 机场跑道 (Runway)
            const runwayGroup = new THREE.Group();
            // 放置在 CONFIG.runwayX
            runwayGroup.position.set(CONFIG.runwayX, 0.1, 0);

            // 主跑道 (沥青)
            const rLen = 8000;
            const runway = new THREE.Mesh(
                new THREE.PlaneGeometry(240, rLen), 
                new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.8 })
            );
            runway.rotation.x = -Math.PI/2;
            runway.receiveShadow = true;
            runwayGroup.add(runway);

            // 跑道标志线 (InstancedMesh 优化)
            const dashGeo = new THREE.PlaneGeometry(5, 80);
            const dashMat = new THREE.MeshBasicMaterial({color: 0xeeeeee});
            const dashes = new THREE.InstancedMesh(dashGeo, dashMat, 40);
            const dummy = new THREE.Object3D();
            for(let i=0; i<40; i++) {
                const z = -rLen/2 + 200 + i * 200;
                dummy.position.set(0, 0.05, z);
                dummy.rotation.x = -Math.PI/2;
                dummy.updateMatrix();
                dashes.setMatrixAt(i, dummy.matrix);
            }
            runwayGroup.add(dashes);

            // 滑行道 (Taxiway)
            const taxiway = new THREE.Mesh(
                new THREE.PlaneGeometry(80, rLen),
                new THREE.MeshStandardMaterial({ color: 0x333333 })
            );
            taxiway.rotation.x = -Math.PI/2;
            taxiway.position.set(300, -0.02, 0); // 右侧平行
            taxiway.receiveShadow = true;
            runwayGroup.add(taxiway);

            // 航站楼 (Terminal Area)
            const termGeo = new THREE.BoxGeometry(400, 50, 1000);
            const termMat = new THREE.MeshStandardMaterial({ color: 0xdddddd });
            const terminal = new THREE.Mesh(termGeo, termMat);
            terminal.position.set(700, 25, 2000);
            terminal.castShadow = true;
            runwayGroup.add(terminal);

            scene.add(runwayGroup);

            // 3. 城市生成 (右侧平原)
            createRealisticCity();
        }

        function createRealisticCity() {
            // 城市位于 X > 500 的区域
            // 使用灰白、浅蓝配色，模拟现代写实建筑
            const count = 6000;
            const boxGeo = new THREE.BoxGeometry(1,1,1);
            boxGeo.translate(0, 0.5, 0); // Pivot at bottom
            
            // 两种材质：混凝土建筑 和 玻璃建筑
            const matConcrete = new THREE.MeshStandardMaterial({ color: 0xaaaaaa, roughness: 0.8 });
            const matGlass = new THREE.MeshStandardMaterial({ color: 0x5588aa, roughness: 0.2, metalness: 0.8 });

            const meshConcrete = new THREE.InstancedMesh(boxGeo, matConcrete, count/2);
            const meshGlass = new THREE.InstancedMesh(boxGeo, matGlass, count/2);
            
            meshConcrete.castShadow = true; meshConcrete.receiveShadow = true;
            meshGlass.castShadow = true; meshGlass.receiveShadow = true;

            const dummy = new THREE.Object3D();
            let idxC = 0, idxG = 0;

            // 路网参数
            const blockSize = 250; // 街区大小
            const cityX = 2000; // 城市中心 X
            const cityZ = 2000; // 城市中心 Z

            for (let x = 0; x < 30; x++) {
                for (let z = -20; z < 20; z++) {
                    // 真实世界坐标
                    const px = 1000 + x * blockSize; // 跑道右侧 1000m 开始
                    const pz = z * blockSize;

                    // 每个街区放置一些建筑
                    // 市中心判断
                    const distCenter = Math.sqrt(Math.pow(px - 3000, 2) + Math.pow(pz - 0, 2));
                    const isDowntown = distCenter < 2000;

                    // 每个街区生成 1-4 栋楼
                    const buildingsInBlock = 2 + Math.floor(Math.random()*3);
                    
                    for(let k=0; k<buildingsInBlock; k++) {
                        const offX = (Math.random()-0.5) * (blockSize - 20);
                        const offZ = (Math.random()-0.5) * (blockSize - 20);
                        
                        const finalX = px + offX;
                        const finalZ = pz + offZ;

                        let w = 30 + Math.random() * 30;
                        let h; 
                        
                        if (isDowntown) {
                            // 摩天大楼区
                            h = 100 + Math.random() * 300;
                            w += 10;
                        } else {
                            // 郊区/工业区
                            h = 15 + Math.random() * 40;
                        }

                        dummy.position.set(finalX, 0, finalZ);
                        dummy.scale.set(w, h, w);
                        dummy.updateMatrix();

                        // 随机分配给玻璃或混凝土，市中心玻璃多
                        if (isDowntown && Math.random() > 0.3) {
                            if(idxG < count/2) {
                                meshGlass.setMatrixAt(idxG++, dummy.matrix);
                            }
                        } else {
                            if(idxC < count/2) {
                                meshConcrete.setMatrixAt(idxC++, dummy.matrix);
                            }
                        }
                    }
                }
            }

            scene.add(meshConcrete);
            scene.add(meshGlass);

            // 简单的黑色平面模拟路网 (提升视觉层次)
            const roads = new THREE.Group();
            const roadMat = new THREE.MeshBasicMaterial({ color: 0x222222 });
            // 纵向主干道
            for(let x = 0; x < 30; x++) {
                const r = new THREE.Mesh(new THREE.PlaneGeometry(15, 10000), roadMat);
                r.rotation.x = -Math.PI/2;
                r.position.set(1000 + x * blockSize, 0.05, 0);
                roads.add(r);
            }
            scene.add(roads);
        }

        // --- 飞机细节模型 ---
        function createDetailedPlane() {
            planeGroup = new THREE.Group();

            // 商务机风格 / 战斗机混合风格
            const matBody = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.4, metalness: 0.2 });
            const matTrim = new THREE.MeshStandardMaterial({ color: 0x0055aa, roughness: 0.4 }); // 蓝色条纹
            const matSteel = new THREE.MeshStandardMaterial({ color: 0x888888, roughness: 0.3, metalness: 0.8 });
            const matGlass = new THREE.MeshStandardMaterial({ color: 0x112233, roughness: 0, metalness: 0.9 });

            // 1. 机身 (Fuselage)
            const fuseGeo = new THREE.CylinderGeometry(2.5, 2.0, 35, 32);
            const fuse = new THREE.Mesh(fuseGeo, matBody);
            fuse.rotation.x = Math.PI/2;
            planeGroup.add(fuse);

            // 机头
            const nose = new THREE.Mesh(new THREE.ConeGeometry(2.5, 8, 32), matBody);
            nose.rotation.x = -Math.PI/2;
            nose.position.z = -21.5;
            planeGroup.add(nose);

            // 驾驶舱
            const cockpit = new THREE.Mesh(new THREE.BoxGeometry(3.5, 2, 6), matGlass);
            cockpit.position.set(0, 2, -10);
            // 简单的 low-poly 倒角效果
            cockpit.scale.set(0.8, 1, 1);
            planeGroup.add(cockpit);

            // 2. 机翼 (Wings) - 后掠翼
            const wingGroup = new THREE.Group();
            const wingShape = new THREE.Shape();
            wingShape.moveTo(0,0);
            wingShape.lineTo(12, 4);
            wingShape.lineTo(12, 8);
            wingShape.lineTo(2, 10);
            wingShape.lineTo(0, 4);
            const wingGeo = new THREE.ExtrudeGeometry(wingShape, { depth: 0.5, bevelEnabled:false });
            
            const wingL = new THREE.Mesh(wingGeo, matBody);
            wingL.rotation.x = Math.PI/2;
            wingL.rotation.z = -0.2; 
            wingL.position.set(2, -1, -5);
            wingGroup.add(wingL);

            const wingR = wingL.clone();
            wingR.scale.y = -1;
            wingR.rotation.z = 0.2;
            wingR.position.set(-2, -1, -5);
            wingGroup.add(wingR);
            planeGroup.add(wingGroup);

            // 3. 引擎 (Engines) - 尾吊式
            const engGeo = new THREE.CylinderGeometry(1.4, 1.2, 6, 24);
            engGeo.rotateX(Math.PI/2);
            const engL = new THREE.Mesh(engGeo, matSteel);
            engL.position.set(3, 1, 10);
            planeGroup.add(engL);
            const engR = engL.clone();
            engR.position.set(-3, 1, 10);
            planeGroup.add(engR);

            // 4. 尾翼 (Tail)
            const vStabShape = new THREE.Shape();
            vStabShape.moveTo(0,0);
            vStabShape.lineTo(6, 6);
            vStabShape.lineTo(8, 6);
            vStabShape.lineTo(10, 0);
            const vStabGeo = new THREE.ExtrudeGeometry(vStabShape, {depth:0.4, bevelEnabled:false});
            const vStab = new THREE.Mesh(vStabGeo, matTrim);
            vStab.rotation.y = -Math.PI/2;
            vStab.position.set(0, 2, 10);
            planeGroup.add(vStab);

            const hStab = new THREE.Mesh(new THREE.BoxGeometry(14, 0.3, 4), matBody);
            hStab.position.set(0, 7, 16); // T型尾翼
            planeGroup.add(hStab);

            // 5. 起落架 (Landing Gear) - 简化
            const gearMat = new THREE.MeshStandardMaterial({color:0x333333});
            const wheelGeo = new THREE.CylinderGeometry(0.8, 0.8, 0.6, 16);
            wheelGeo.rotateZ(Math.PI/2);
            
            const noseGear = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.2, 3), matSteel);
            noseGear.position.set(0, -2.5, -15);
            const noseWheel = new THREE.Mesh(wheelGeo, gearMat);
            noseWheel.position.y = -1.5;
            noseGear.add(noseWheel);
            planeGroup.add(noseGear);

            const mainGearL = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.2, 3), matSteel);
            mainGearL.position.set(3, -2.5, 0);
            const wheelL = new THREE.Mesh(wheelGeo, gearMat);
            wheelL.position.y = -1.5;
            mainGearL.add(wheelL);
            planeGroup.add(mainGearL);

            const mainGearR = mainGearL.clone();
            mainGearR.position.set(-3, -2.5, 0);
            planeGroup.add(mainGearR);

            // 影子模拟 (简单黑色平面)
            shadowPlane = new THREE.Mesh(
                new THREE.PlaneGeometry(20, 30),
                new THREE.MeshBasicMaterial({color:0x000000, opacity:0.4, transparent:true})
            );
            shadowPlane.rotation.x = -Math.PI/2;
            scene.add(shadowPlane);

            planeGroup.castShadow = true;
            planeGroup.traverse(c => { if(c.isMesh) { c.castShadow = true; c.receiveShadow = true; }});
            scene.add(planeGroup);
        }

        function handleKey(e, val) {
            let k = e.key.toLowerCase();
            if (k === " ") k = "space";
            if (k === "v" && val === 1) changeCamera();
            if (input.hasOwnProperty(k)) input[k] = val;
        }

        function changeCamera() {
            cameraMode = (cameraMode + 1) % 2;
        }

        function onResize() {
            camera.aspect = window.innerWidth/window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- 动画循环 ---
        function animate() {
            requestAnimationFrame(animate);
            const dt = Math.min(clock.getDelta(), 0.1);

            updatePhysics(dt);

            if (planeGroup) {
                // 物理同步
                planeGroup.position.copy(physics.pos);
                planeGroup.quaternion.copy(physics.quat);

                // 影子跟随
                shadowPlane.position.set(physics.pos.x, 0.05, physics.pos.z);
                shadowPlane.rotation.z = planeGroup.rotation.y;

                // 相机逻辑
                if (cameraMode === 0) { // 尾随视角
                    const relativeOffset = new THREE.Vector3(0, 15, 80);
                    const cameraOffset = relativeOffset.applyMatrix4(planeGroup.matrixWorld);
                    // 增加一点延迟感 (Lerp factor 越小越重)
                    camera.position.lerp(cameraOffset, 0.05);
                    const lookAtPos = planeGroup.position.clone().add(new THREE.Vector3(0, 0, -100).applyQuaternion(physics.quat));
                    camera.lookAt(lookAtPos);
                } else if (cameraMode === 1) { // 塔台视角
                    camera.position.set(CONFIG.runwayX + 500, 160, CONFIG.runwayZ + 1000); // 塔台位置
                    camera.lookAt(planeGroup.position);
                }
            }

            // UI 更新
            const speedKnots = Math.floor(physics.vel.length() * 1.94);
            document.getElementById('hud-spd').innerText = speedKnots;
            document.getElementById('hud-alt').innerText = Math.floor(physics.pos.y * 3.28);
            document.getElementById('hud-rpm').innerText = Math.floor(physics.throttle * 100);
            document.getElementById('throttle-fill').style.height = (physics.throttle * 100) + '%';
            
            // 航向
            const euler = new THREE.Euler().setFromQuaternion(physics.quat);
            let hdg = Math.floor(THREE.MathUtils.radToDeg(-euler.y) % 360);
            if (hdg < 0) hdg += 360;
            document.getElementById('hud-hdg').innerText = hdg.toString().padStart(3, '0');

            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
